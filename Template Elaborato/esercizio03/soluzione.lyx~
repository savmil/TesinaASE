#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\begin_preamble
\usepackage{listings,xcolor,courier,bookmark}
\usepackage{listingsutf8}
\definecolor{darkblue}{named}{blue}
\definecolor{darkred}{named}{red}
\definecolor{grau}{named}{gray}
\let\Righttorque\relax
\lstset{
captionpos=b,
commentstyle=\color[rgb]{0.133,0.545,0.133},
keywordstyle=\color{darkblue},
stringstyle=\color{darkred},
extendedchars=true,
basicstyle=\small\ttfamily,
showstringspaces=false,
tabsize=2,
numbers=left,
numberstyle=\tiny,
breakautoindent  = true,
breakindent      = 2em,
breaklines       = true,
postbreak        = ,
prebreak         = \raisebox{-.8ex}[0ex][0ex]{\Righttorque},
showspaces=false, 
showtabs=false, 
showstringspaces=false,
language=VHDL,
frame=single,
morecomment=[s]{--}
}


\renewcommand*{\lstlistingname}{Codice Componente}


\usepackage{fancyhdr}
\pagestyle{fancy}

\fancyhead{} 
\fancyfoot{} 

\fancyhead[RO,LE]{\bfseries \leftmark}
\fancyfoot[LE,RO]{\thepage}
\fancyfoot[LO,CE]{Tesina in ASE: Architetture dei Sistemi di Elaborazione}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\date{}
\cfoot{}
\end_preamble
\use_default_options true
\master Tesina.lyx
\maintain_unincluded_children false
\language italian
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2.5cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Section
Latch RS
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Descrivere la soluzione relizzata per mezzo di schematici e riportare il
 codice dei soli componenti significativi.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Schematico
\end_layout

\begin_layout Standard
Si è scelto di implementare il latch RS in logica 1-attiva con due porte
 NOR, questo implica che, quando S=1 e R=0, l'uscita Q è alta, che lo stato
 neutro degli ingressi è S=R=0 e quello non ammesso è S=R=1, il quale, seguito
 dal passaggio allo stato neutro, produce un'uscita non stabile e soggetta
 ad un transitorio, che può portare ad alee e quindi a corse.
 Dualmente, grazie alla simmetria del circuito, è possibile cambiare la
 logica in 0-attiva utilizzando due porte NAND.
\end_layout

\begin_layout Subsection
Codice
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Nell'eventialità in cui alcuni componenti sia stati utilizzati in altri
 esercizi inserire solo un riferimento (es.
 Multiplexer Generico - traccia n° 1)
\end_layout

\begin_layout Plain Layout
Segue un esempio di inclusione di codice
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
RS_Latch
\end_layout

\begin_layout Standard
Questo componente è stato realizzato con un'architettura di tipo Structural,
 connettendo due componenti 
\shape italic
nor_gate
\shape default
, che non fanno altro che la NOR dei due ingressi.
 Le uscite di ogni porta nor viene poi retroazionata all'ingresso dell'altra
 porta.
\begin_inset Newline newline
\end_inset

Il progetto ISE del componente in questione è osservabile a questo link:
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
href{run:progetti/latch_flip-flop/rs_latch/rs_latch.xise}{RS
\backslash
_Latch ISE}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Simulazione
\end_layout

\begin_layout Subsubsection
Behavioral
\end_layout

\begin_layout Standard
In questo tipo di simulazione, viene modellato solo il comportamento funzionale
 del sistema, infatti le porte sono considerate ideali e quindi senza ritardo;
 per questo motivo quando provo ad utilizzare la configurazione degli ingressi
 non ammessa R=S=1 (che viola il vincolo logico 
\begin_inset ERT
status open

\begin_layout Plain Layout

$R
\backslash
cdot S=0$
\end_layout

\end_inset

 e quindi quello 
\begin_inset ERT
status open

\begin_layout Plain Layout

$Q=not(
\backslash
neg Q)$
\end_layout

\end_inset

) e poi nello stesso istante (80 ns) le abbasso entrambe , questo genera
 degli eventi oscillatori che producono cicli di delta cycle.
 Questi però non riusciamo ad osservarli in simulazione poichè il tempo
 di simulazione non avanza e viene generato un errore che indica che si
 è raggiunto il limite di iterazioni, dovuto al fatto che il sistema non
 riesce a raggiungere uno stato stabile.
 Queste oscillazioni invece sono visibili nella simulazione Post-Map, in
 cui vengono introdotti i ritardi dei componenti di libreria ma non quelli
 relativi alle loro connessioni.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[H]
\end_layout

\begin_layout Plain Layout

	
\backslash
centering
\end_layout

\begin_layout Plain Layout

	
\backslash
includegraphics[scale=0.8]{esercizio03/images/rs_latch_behavioral.png}
\end_layout

\begin_layout Plain Layout

	
\backslash
caption{Simulazione del latch RS Behavioral}
\end_layout

\begin_layout Plain Layout

	
\backslash
label{fig:RS_behavioral}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Post-Sintesi
\end_layout

\begin_layout Standard
La simulazione di Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:RS_post-route"

\end_inset

 rappresenta l'evoluzione del sistema in seguito all'operazione di Place
 & Route che, dopo aver utilizzato dei componenti della libreria Xilinx
 con i relativi ritardi dovuti ai tempi di commutazione, collega tali componenti
, tenendo in considerazione i ritardi delle connessioni relative al routing
 effettuato.
 Proprio grazie a questi ritardi la simulazione continua e non si blocca
 come quella precedente quando gli ingressi passano dal valore R=S=1 a R=S=0,
 ma vengono introdotte delle asimmetrie nel circuito che portano le uscite
 ad assumere dei valori che rispettano i vincoli logici, nel nostro caso
 sono Q=1 e 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
lnot$
\end_layout

\end_inset

Q=0 a 86 ns.
 Però è importante sottolineare che questi valori prodotti in uscita non
 sono deterministici, perchè generati da corse e quindi è preferibile non
 ottenerli rispettando il vincolo che proibisce l'utilizzo di entrambi gli
 ingressi alti.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[H]
\end_layout

\begin_layout Plain Layout

	
\backslash
centering
\end_layout

\begin_layout Plain Layout

	
\backslash
includegraphics[scale=0.8]{esercizio03/images/rs_latch_post-route.png}
\end_layout

\begin_layout Plain Layout

	
\backslash
caption{Simulazione del latch RS Post-Route}
\end_layout

\begin_layout Plain Layout

	
\backslash
label{fig:RS_post-route}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Latch RS abilitato
\end_layout

\begin_layout Subsection
Schematico
\end_layout

\begin_layout Standard
Questo tipo di latch deriva dal latch RS precedente, al quale si antepone
 una rete combinatoria formata da due porte AND, i cui ingressi sono R ed
 S e in più un segnale di abilitazione, che può essere un clock, ma che
 in nessun caso rende sincrona la rete.
\end_layout

\begin_layout Subsection
Codice
\end_layout

\begin_layout Subsubsection
RS_Latch_Clocked
\end_layout

\begin_layout Standard
Tale componente è stato realizzato con un'architettura Structural, connettendo,
 tramite i due segnali 
\shape italic
r_clocked
\shape default
 ed 
\shape italic
s_clocked
\shape default
, le uscite di due porte AND, realizzate con il componente 
\shape italic
and_gate
\shape default
, agli ingressi R ed S del componente 
\shape italic
rs_latch
\shape default
 visto precedentemente (componente 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
href{run:progetti/latch_flip-flop/rs_latch_clocked/rs_latch.vhd}{RS
\backslash
_Latch}
\end_layout

\end_inset

).
 Ovviamente in ingresso alle porte AND ci saranno i segnali di set e reset,
 nonché un clock che funge da segnale di abilitazione.
\begin_inset Newline newline
\end_inset

Il progetto ISE del componente in questione è osservabile a questo link:
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
href{run:progetti/latch_flip-flop/rs_latch_clocked/rs_latch_clocked.xise}{RS
\backslash
_Latch
\backslash
_Clocked ISE}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Simulazione
\end_layout

\begin_layout Subsubsection
Behavioral
\end_layout

\begin_layout Standard
In Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:RS_clk_behavioral"

\end_inset

 è rappresentata la simulazione behavioral del latch RS abilitato, che si
 comporta come un normale latch RS quando il clock è alto, altrimenti mantiene
 lo stato precedente.
 Inoltre si osserva, come nel caso del latch RS, che la simulazione si ferma
 (in questo caso a 50 ns) e viene generato un errore che indica che si è
 raggiunto il limite di iterazioni.
 Tutto questo è dovuto al fatto che, avendo utilizzanto nel testbench, a
 45 ns, la configurazione degli ingressi non ammessa R=S=1, vengono generate
 delle oscillazioni non osservabili in questo tipo di simulazione e che
 probabilmente sono causate dal successivo abbassamento del segnale di clock
 alla soglia dei 50 ns, che porterebbe il sistema a conservare lo stato
 precedente forzando i valori di ingresso R=S=0.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[H]
\end_layout

\begin_layout Plain Layout

	
\backslash
centering
\end_layout

\begin_layout Plain Layout

	
\backslash
includegraphics[scale=0.8]{esercizio03/images/rs_latch_clocked_behavioral.png}
\end_layout

\begin_layout Plain Layout

	
\backslash
caption{Simulazione del latch RS abilitato Behavioral}
\end_layout

\begin_layout Plain Layout

	
\backslash
label{fig:RS_clk_behavioral}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Post-Sintesi
\end_layout

\begin_layout Standard
In Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:RS_clk_post-route"

\end_inset

 è mostrata la simulazione Post-Route del sistema.
 Come si è verificato per il lactch RS, anche qui, utilizzando i componenti
 della libreria Xilinx e considerando i loro ritardi e quelli delle connessioni,
 si osserva che la simulazione continua e non si arresta, grazie al fatto
 che vengono forzati dei valori in uscita (Q=1 e 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
lnot$
\end_layout

\end_inset

Q=0 a 55ns) dovuti all'asimmetria introdotta dopo l'operazione di Place
 & Route.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[H]
\end_layout

\begin_layout Plain Layout

	
\backslash
centering
\end_layout

\begin_layout Plain Layout

	
\backslash
includegraphics[scale=0.8]{esercizio03/images/rs_latch_clocked_post-route.png}
\end_layout

\begin_layout Plain Layout

	
\backslash
caption{Simulazione del latch RS abilitato Post-Route}
\end_layout

\begin_layout Plain Layout

	
\backslash
label{fig:RS_clk_post-route}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Latch D abilitato
\end_layout

\begin_layout Subsection
Schematico
\end_layout

\begin_layout Standard
Il latch D abilitato può essere realizzato a partire da un latch RS abilitato
 i cui ingressi R ed S corrispondono al valore D in ingresso rispettivamente
 una volta negato tramite una porta NOT e una volta no.
 Questo latch permette di avere in uscita Q il valore D in ingresso, ma
 ritardato di un certo 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Delta$
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Codice
\end_layout

\begin_layout Subsubsection
D_Latch_Clocked
\end_layout

\begin_layout Standard
Questo componente è stato creato come un'architettura Structural a partire
 dal componente 
\shape italic
rs_latch_clocked
\shape default
 visto in precedenza (componente 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
href{run:progetti/latch_flip-flop/d_latch/rs_latch_clocked.vhd}{RS
\backslash
_Latch
\backslash
_Clocked}
\end_layout

\end_inset

).
 L'ingresso D viene colleggato all'ingresso S del latch rs abilitato e viene
 utilizzato un segnale 
\shape italic
notd
\shape default
 per negare D e collegarlo all'ingresso R.
\begin_inset Newline newline
\end_inset

Il progetto ISE del componente in questione è osservabile a questo link:
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
href{run:progetti/latch_flip-flop/d_latch/d_latch.xise}{D
\backslash
_latch
\backslash
_Clocked ISE}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Simulazione
\end_layout

\begin_layout Subsubsection
Behavioral
\end_layout

\begin_layout Standard
Come si nota dalla simulazione behavioral di Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:D_clk_behavioral"

\end_inset

 quando D e il clock sono alti il segnale in uscita Q è alto, altrimenti
 o viene mantenuto lo stato precedente quando il clock è basso oppure quando
 D è basso e il clock è altro, sarà l'uscita 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
lnot$
\end_layout

\end_inset

Q ad essere alta.
 Anche in questo caso come in quelli precedenti, la simulazione si arresta
 a 40 ns a causa di un errore che indica il raggiungimento del limite di
 iterazioni dovuto alla generazione di cicli di delta cycle, che non permettono
 di giungere ad uno stato stabile.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[H]
\end_layout

\begin_layout Plain Layout

	
\backslash
centering
\end_layout

\begin_layout Plain Layout

	
\backslash
includegraphics[scale=0.8]{esercizio03/images/d_latch_clocked_behavioral.png}
\end_layout

\begin_layout Plain Layout

	
\backslash
caption{Simulazione del latch D abilitato Behavioral}
\end_layout

\begin_layout Plain Layout

	
\backslash
label{fig:D_clk_behavioral}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Post-Sintesi
\end_layout

\begin_layout Standard
In Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:D_clk_post-route"

\end_inset

 è rappresentata la simulazione Post-Route del componente.
 Grazie all'introduzione dei ritardi dei componenti della libreria Xilinx
 e a quelli relatvi ai collegamenti tra gli stessi, la simulazione è in
 grado di continuare senza bloccarsi; ovviamente questo comporta un ritardo
 nella generazione delle uscite che commutano un po' dopo il sollevamento
 del segnale di clock.
 Ad aumentare ulteriormente il ritardo è l'aggiunta della porta NOT, che
 aumenta ulteriormente il tempo di commutazione rispetto al latch RS abilitato.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[H]
\end_layout

\begin_layout Plain Layout

	
\backslash
centering
\end_layout

\begin_layout Plain Layout

	
\backslash
includegraphics[scale=0.8]{esercizio03/images/d_latch_clocked_post-route.png}
\end_layout

\begin_layout Plain Layout

	
\backslash
caption{Simulazione del latch D abilitato Post-Route}
\end_layout

\begin_layout Plain Layout

	
\backslash
label{fig:D_clk_post-route}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Latch T
\end_layout

\begin_layout Subsection
Schematico
\end_layout

\begin_layout Standard
Il latch T può essere realizzato similmente al latch RS abilitato, solo
 che, in ingresso alle porte AND, vanno le uscite retroazionate al posto
 degli ingressi di reset e set e il segnale T che, quando è abilitato, non
 fa altro che commutare l'uscita Q.
\end_layout

\begin_layout Subsection
Codice
\end_layout

\begin_layout Subsubsection
T_Latch
\end_layout

\begin_layout Standard
L'approccio utilizzato per la realizzazione di questo tipo di latch è quello
 strutturale, in base al quale, a partire dal componente 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
href{run:progetti/latch_flip-flop/t_latch/rs_latch.vhd}{RS
\backslash
_Latch}
\end_layout

\end_inset

 visto in precedenza, sono state aggiunte due porte AND, in ingresso alle
 quali vanno il segnale T e le uscite Q e 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
lnot$
\end_layout

\end_inset

Q del latch RS retroazionate.
 Per fare questo sono stati utilizzati quattro segnali: due (
\shape italic
retro_q
\shape default
 e 
\shape italic
retro_notq
\shape default
) utilizzati per le uscite del latch e altri due (
\shape italic
retro_q_delayed
\shape default
 e 
\shape italic
retro_notq_delayed
\shape default
) utilizzati per ritardare, tramite la parola chiave after, tali uscite
 in modo che possano essere utilizzate in ingresso alle porte AND, questo
 perchè altrimenti le uscite non riescono a commutare.
 
\begin_inset Newline newline
\end_inset

Il progetto ISE del componente in questione è osservabile a questo link:
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
href{run:progetti/latch_flip-flop/t_latch/t_latch.xise}{T
\backslash
_Latch ISE}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Simulazione
\end_layout

\begin_layout Subsubsection
Behavioral
\end_layout

\begin_layout Standard
In figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:t_behavioral"

\end_inset

 si osserva la simulazione Behavioral del latch_t.
 Così come si nota quando T è alto possono avvenire una o più commutazione
 delle uscite in base alla sua durata, infatti T dovrebbe essere alto per
 un tempo sufficientemente grande affinchè avvenga una commutazione ma sufficien
temente piccolo affinchè non ne avvengano altre.
 Si noti inoltre, che quando T è basso, il sistema mantine lo stato precedente.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[H]
\end_layout

\begin_layout Plain Layout

	
\backslash
centering
\end_layout

\begin_layout Plain Layout

	
\backslash
includegraphics[scale=0.8]{esercizio03/images/t_latch_behavioral.png}
\end_layout

\begin_layout Plain Layout

	
\backslash
caption{Simulazione del latch T Behavioral}
\end_layout

\begin_layout Plain Layout

	
\backslash
label{fig:t_behavioral}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Post-Sintesi
\end_layout

\begin_layout Standard
Nella simulazione Post-Sintesi invece, dato che la parola chiave after,
 usata precedentemente per permettere la commutazione delle uscite, non
 è sintetizzabile, allora le uscite non cambiano stato e permangono per
 tutta la durata della simulazione in uno stato 
\begin_inset Quotes eld
\end_inset

uninitialized
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Section
Latch JK abilitato
\end_layout

\begin_layout Subsection
Schematico
\end_layout

\begin_layout Standard
Il latch JK è strutturato in maniera simile al latch RS abilitato, ciò che
 cambia è che le porte AND prendono in ingresso le uscite retroazionate,
 così come avviene per il latch T, il clock e due segnali J e K.
 In base alla configurazione di questi due segnali cambia il funzionamento
 del latch, poiché se K=J=1, esso si comporta come un latch T, altrimenti
 si comporta come un latch RS in cui R=K e S=J.
\end_layout

\begin_layout Subsection
Codice
\end_layout

\begin_layout Subsubsection
JK_Latch_Clocked
\end_layout

\begin_layout Standard
Questo tipo di componente è stato realizzato con un'architettura Structural,
 in cui si antepongono ad un latch RS (componente 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
href{run:progetti/latch_flip-flop/jk_latch/rs_latch.vhd}{RS
\backslash
_Latch}
\end_layout

\end_inset

), due porte AND a tre ingressi, cioè il clock, K o J, e una delle due uscite
 retroazionata.
 Questo avviene tramite l'utilizzo di quattro segnali, ovvero 
\shape italic
q_feedback
\shape default
 e 
\shape italic
notq_feedback
\shape default
, utilizzati per le uscite del latch RS, e 
\shape italic
q_feedback_delayed
\shape default
 e 
\shape italic
notq_feedback_delayed
\shape default
, utilizzati per ritardare tali segnali, in modo che possano essere retroazionat
i in ingresso alle porte AND e quindi permettere la commutazione.
 Sono presenti inoltre due ingressi di 
\shape italic
clear
\shape default
 e 
\shape italic
preset
\shape default
, messi in OR con le uscite delle porte AND, in modo da inizializzare il
 dispositivo, tramite i segnali 
\shape italic
in_latch_r
\shape default
 e 
\shape italic
in_latch_s
\shape default
, messi in ingresso al latch RS.
 
\begin_inset Newline newline
\end_inset

Il progetto ISE del componente in questione è osservabile a questo link:
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
href{run:progetti/latch_flip-flop/jk_latch/jk_latch_clocked.xise}{JK
\backslash
_Latch ISE}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Simulazione
\end_layout

\begin_layout Subsubsection
Behavioral
\end_layout

\begin_layout Standard
In Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:jk_clk_behavioral"

\end_inset

 è rappresentata la simulazione Behavioral del funzionamento del latch JK
 abilitato.
 Si nota che, così come ci aspettiamo, quando J è alto, Q è alto, mentre
 quando K è alto, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
lnot$
\end_layout

\end_inset

Q è alto; quando invece sia J che K sono alti, il sistema funziona come
 un latch T e quindi le uscite commutano un certo numero di volte, che dipende
 dalla durata dello stato J=K=1.
 Ovviamente quando sia J che K sono bassi oppure il clock è basso, il sistema
 permane nello stato precedente.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[H]
\end_layout

\begin_layout Plain Layout

	
\backslash
centering
\end_layout

\begin_layout Plain Layout

	
\backslash
includegraphics[scale=0.8]{esercizio03/images/jk_latch_clocked_behavioral.png}
\end_layout

\begin_layout Plain Layout

	
\backslash
caption{Simulazione del latch JK abilitato Behavioral}
\end_layout

\begin_layout Plain Layout

	
\backslash
label{fig:jk_clk_behavioral}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Post-Sintesi
\end_layout

\begin_layout Standard
Nella simulazione Post-Route di Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:jk_clk_post-route"

\end_inset

 vengono utilizzati i componenti della libreria Xilinx con i relativi ritardi
 e quelli dovuti ai collegamenti tra gli stessi e quindi notiamo un certo
 delay nella commutazione delle uscite rispetto al caso Behavioral.
 Si nota inoltre che in seguito alla fine della condizione in cui J=K=1,
 anzichè permanere in uno stato, le uscite commutano sempre, probabilmente
 a causa di alcune asimmetrie introdotte nel circuito dalla fase di sintesi.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[H]
\end_layout

\begin_layout Plain Layout

	
\backslash
centering
\end_layout

\begin_layout Plain Layout

	
\backslash
includegraphics[scale=0.8]{esercizio03/images/jk_latch_clocked_post-route.png}
\end_layout

\begin_layout Plain Layout

	
\backslash
caption{Simulazione del latch JK abilitato Post-Route}
\end_layout

\begin_layout Plain Layout

	
\backslash
label{fig:jk_clk_post-route}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Flip-Flop D Edge Triggered
\end_layout

\begin_layout Subsection
Schematico
\end_layout

\begin_layout Standard
Un Flip-Flop D Edge Triggered che commuta sul fronte di discesa del clock
 può essere realizzato, così come si evince dalla Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ffd"

\end_inset

, attraverso 6 porte NOR opportunamente interconnesse.
 Quando il clock è alto, l'uscita delle porte G2 e G3 viene forzata a 0,
 quindi il latch 3 mantiene il proprio stato delle uscite e il latch 1 e
 il latch 2 seguono il valore D e 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
lnot$
\end_layout

\end_inset

D rispettivamente.
 All'atto della transizione del clock dal valore alto a quello basso, i
 valori di D e 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
lnot$
\end_layout

\end_inset

D vengono propagati agli ingressi del latch 3 e quindi in uscita.
 Considerando 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
tau$
\end_layout

\end_inset

 il ritardo di ogni porta, la rete impiega 5
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
tau$
\end_layout

\end_inset

 per commutare.
 Si noti inoltre, un ulteriore ingresso alla porta G2, che non è altro che
 l'uscita della porta G1 retroazionata; questo elemento, può sembrare ridondante
, in realtà evita il presentarsi di un'alea che, all'atto della transizione
 del clock 1->0, causerebbe un valore inatteso all'uscita della porta G2,
 dovuto al ritardo di 3
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
tau$
\end_layout

\end_inset

 per propagare l'ingresso R1a, infatti l'uscita della porta G1 ha lo stesso
 valore dell'uscita della porta G3, solo che è possibile ottenerla con un
 ritardo pari solo a 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
tau$
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[H]
\end_layout

\begin_layout Plain Layout

	
\backslash
centering
\end_layout

\begin_layout Plain Layout

	
\backslash
includegraphics[scale=0.8]{esercizio03/images/ffd.png}
\end_layout

\begin_layout Plain Layout

	
\backslash
caption{Schematico Flip-Flop D Edge Triggered}
\end_layout

\begin_layout Plain Layout

	
\backslash
label{fig:ffd}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Codice
\end_layout

\begin_layout Subsubsection
FlipFlop_D_edge
\end_layout

\begin_layout Standard
Il Flip-Flop D Edge Triggered è stato realizzato con un'architettura Structural
 componendo 6 porte NOR, opportunamente connesse con dei segnali da G1 a
 G6 che rappresentano le uscite delle omonime porte.
 Si noti che per settare l'uscita della porta NOR G2, che ha tre ingressi,
 è stata applicata una porta NOT al risultato dell'OR tra l'uscita della
 porta G3, il clock e l'uscita della porta G1, utilizzata per eliminare
 l'alea.
\begin_inset Newline newline
\end_inset

Il progetto ISE del componente in questione è osservabile a questo link:
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
href{run:progetti/latch_flip-flop/flipflop_d_edge/flipflop_d_edge.xise}{FlipFlop
\backslash
_D
\backslash
_Edge ISE}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Simulazione
\end_layout

\begin_layout Subsubsection
Behavioral
\end_layout

\begin_layout Standard
Nella simulazione Behavioral di Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ffd_behavioral"

\end_inset

 si osserva il funzionamento del Flip Flop D.
 Come si nota la commutazione delle uscite avviene in corrispondenza del
 fronte di discesa del clock in maniera istantanea, non avendo usato a questo
 livello i componenti della libreria Xilinx.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[H]
\end_layout

\begin_layout Plain Layout

	
\backslash
centering
\end_layout

\begin_layout Plain Layout

	
\backslash
includegraphics[scale=0.8]{esercizio03/images/flipflop_d_edge_behavioral.png}
\end_layout

\begin_layout Plain Layout

	
\backslash
caption{Simulazione del Flip-Flop D Edge Triggered Behavioral}
\end_layout

\begin_layout Plain Layout

	
\backslash
label{fig:ffd_behavioral}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Post-Sintesi
\end_layout

\begin_layout Standard
In Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ffd_post-route"

\end_inset

 è rappresetata una simulazione Post-Route del Flip-Flop D.
 Come c'era da aspettarsi, tenendo in considerazione i ritardi dei componenti
 utilizzati e quelli relativi al routing, la commutazione delle uscite non
 avviene istantanemente rispetto al fronte di discesa del clock, ma con
 un ritardo che è circa 6 ns, che quindi è in linea con il ritardo di 5
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
tau$
\end_layout

\end_inset

 predetto precedentemente.
 Si noti inoltre l'assenza di alee grazie all'aggiunta del collegamento
 dell'uscita della porta G1 all'ingresso della porta G2.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[H]
\end_layout

\begin_layout Plain Layout

	
\backslash
centering
\end_layout

\begin_layout Plain Layout

	
\backslash
includegraphics[scale=0.8]{esercizio03/images/flipflop_d_edge_post-route.png}
\end_layout

\begin_layout Plain Layout

	
\backslash
caption{Simulazione del Flip-Flop D Edge Triggered Post-Route}
\end_layout

\begin_layout Plain Layout

	
\backslash
label{fig:ffd_post-route}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Flip-Flop RS Master-Slave
\end_layout

\begin_layout Subsection
Schematico
\end_layout

\begin_layout Standard
Un Flip-Flop RS Master-Slave viene realizzato collegando in cascata due
 latch RS abilitati da un segnale di clock nel caso del primo latch (master)
 è affermato, mentre nel caso del secondo (slave) è negato.
 Questo comporta che i due latch non funzionano contemporaneamente ma quando
 uno è attivo l'altro è disattivo e viceversa.
\end_layout

\begin_layout Subsection
Codice
\end_layout

\begin_layout Subsubsection
FlipFlop_RS_MS
\end_layout

\begin_layout Standard
Il componente 
\shape italic
flipflop_rs_ms
\shape default
 è stato realizzato con un approccio Structural, poichè sono stati utilizzati
 due componenti rs_latch_clocked visti in precedeza (componente 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
href{run:progetti/latch_flip-flop/flipflop_rs_ms/rs_latch_clocked.vhd}{RS
\backslash
_Latch
\backslash
_Clocked}
\end_layout

\end_inset

), collegati tramite i due segnali 
\shape italic
q_master
\shape default
 e 
\shape italic
notq_master
\shape default
 che vanno in ingresso rispettivamente al set e al reset del latch slave.
 Infine è stata utilizzata una porta NOT per negare il segnale di clock
 che è stato poi collegato al secondo latch.
\begin_inset Newline newline
\end_inset

Il componente in questione è osservabile a questo link: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
href{run:progetti/latch_flip-flop/flipflop_rs_ms/flipflop_rs_ms.xise}{FlipFlop
\backslash
_RS
\backslash
_MS ISE}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Simulazione
\end_layout

\begin_layout Subsubsection
Behavioral
\end_layout

\begin_layout Standard
In Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ffrs_behavioral"

\end_inset

 viene mostrata la simulazione Behavioral quindi il funzionamento di questo
 tipo di circuito.
 Come si nota, quello che di fatto realizza è un flip-flop RS pilotato sul
 fronte di discesa del clock, in corrispondeza del quale avviene la commutazione
 delle uscite Q e 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
lnot$
\end_layout

\end_inset

Q.
 In questo caso la simulazione continua fino alla fine poichè non è stata
 utilizzata la configurazione R=S=1 non ammessa e quindi non si sono generati
 eventi oscillatori.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[H]
\end_layout

\begin_layout Plain Layout

	
\backslash
centering
\end_layout

\begin_layout Plain Layout

	
\backslash
includegraphics[scale=0.8]{esercizio03/images/flipflop_rs_ms_behavioral.png}
\end_layout

\begin_layout Plain Layout

	
\backslash
caption{Simulazione del Flip-Flop RS Master-Slave Behavioral}
\end_layout

\begin_layout Plain Layout

	
\backslash
label{fig:ffrs_behavioral}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Post-Sintesi
\end_layout

\begin_layout Standard
Nella simulazione Post-Route di Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ffd_post-route"

\end_inset

, come nei casi precedenti notiamo che la commutazione delle uscite avviene
 con circa 5-6 ns di ritardo, dovuto all'utilizzo dei componenti della libreria
 Xilinx e ai ritardi dei loro collegamenti.
 Fortunatamente, in questo caso, il ritardo della porta NOT sembra non pregiudic
are il funzionamento del sistema, infatti il master e lo slave funzionano
 alternativamente, cosa che potrebbe non accadere se il ritardo della porta
 NOT fosse troppo grande e quindi non si riuscisse a determinare l'uscita.
 Questo però è un caso limite poiché di solito il ritardo della porta NOT
 è un 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
tau$
\end_layout

\end_inset

 piccolissimo.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[H]
\end_layout

\begin_layout Plain Layout

	
\backslash
centering
\end_layout

\begin_layout Plain Layout

	
\backslash
includegraphics[scale=0.8]{esercizio03/images/flipflop_rs_ms_post-route.png}
\end_layout

\begin_layout Plain Layout

	
\backslash
caption{Simulazione del Flip-Flop RS Master-Slave Post-Route}
\end_layout

\begin_layout Plain Layout

	
\backslash
label{fig:ffd_post-route}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\end_body
\end_document
